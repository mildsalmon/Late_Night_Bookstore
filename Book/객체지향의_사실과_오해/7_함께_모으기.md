# 1. 커피 전문점 도메인

## A. 커피 전문점이라는 세상

객체지향의 관점에서 커피 전문점이라는 도메인은 손님 객체, 메뉴 항목 객체, 메뉴판 객체, 바리스타 객체, 커피 객체로 구성된 작은 세상이다.

객체들 간의 관계

- 손님은 어떤 식으로든 메뉴판을 알아야 하며
- 손님과 파리스타 사이에도 관계가 존재한다.
- 바리스터는 자신이 만든 커피와 관계를 맺는다.

우리가 할 수 있는 일은 동적인 객체를 정적인 타입으로 추상화해서 복잡성을 낮추는 것이다. 타입은 분류를 위해 사용된다는 것을 기억하라. 상태와 무관하게 동일하게 행동할 수 있는 객체들은 동일한 타입의 인스턴스로 분류할 수 있다.

타입 간에 어떤 관계가 존재하는지 살펴보자.

선에 그려진 속이 찬 마름모는 포함(containment) 관계 또는 합성(composition) 관계. -> 메뉴 항목이 메뉴판에 포함된다는 사실을 표현한다. 숫자 4는 메뉴판에 포함되는 메뉴 항목이 4개라는 것을 의미한다.

[그림7.3]

단순한 선으로 연결하는 경우 연관(association) 관계라고 한다 -> 한 타입의 인스턴스가 다른 타입의 인스턴스를 포함하지는 않지만 서로 알고 있어야 할 경우.

바리스타 타입은 커피를 제조해야 하므로 커피 타입을 알고 있어야 한다. 메뉴판 타입과 커피 타입 중 어떤 것도 바리스타의 일부가 아니므로 이 관계 역시 포함관계는 아니다.

[그림7.5]

소프트웨어가 대상으로 하는 영역인 도메인을 단순화해서 표현한 모델을 도메인 모델이라고 한다.

적절한 객체에게 적절한 책임을 할당해야 한다. -> 협력을 설계하는 것

> 어떤 타입이 도메인을 구성하느냐와 타입들 사이에 어떤 관계가 존재하는지를 파악함으로써 도메인을 이해하는 것이다.

# 2. 설계하고 구현하기

## A. 커피를 주문하기 위한 협력 찾기

객체지향의 첫 번째 목표는 훌륭한 협력을 설계하는 것이다. 훌륭한 객체는 훌륭한 협력을 설계할 때만 얻을 수 있다.

메시지가 객체를 선택하게 해야 한다. 이 말은 메시지를 먼저 선택하고 그 후에 메시지를 수신하기에 적절한 객체를 선택해야 한다는 것을 의미한다. 이제 메시지를 수신할 객체는 메시지를 처리할 책임을 맡게 되고 객체가 수신하는 메시지는 객체가 외부에 제공하는 공용 인터페이스에 포함된다.

[그림7.6]

메시지 위에 붙은 화살표는 메시지에 담아 전달될 부가적인 정보인 인자를 의미한다.

메시지를 처리할 객체를 찾고 있다면 먼저 도메인 모델 안에 책임을 수행하기에 적절한 타입이 존재하는지 살펴보라. 적절한 타입을 발견했다면 책임을 수행할 객체를 그 타입의 인스턴스로 만들어라.

어떤 객체가 커피를 주문할 책임을 져야 하는가? -> 손님. 따라서 메시지를 처리할 객체는 손님 타입의 인스턴스다. 이제 손님 객체는 커피를 주문할 책임을 할당받았다.

[그림7.7]

손님이 할당된 책임을 수행하는 도중에 스스로 할 수 없는 일이 있다면 다른 객체에게 이를 요청해야 한다. 이 요청이 바로 손님 객체에서 외부로 전송되는 메시지를 정의한다.

[그림7.8]

화살표 아래에 붙은 손님으로 향하는 작은 화살표는 이 메시지를 수신한 객체가 손님에게 무엇을 응답해야 하는지를 나타낸다.

> 객체지향 세계에서는 모든 객체가 능동적이고 자율적인 존재다.

> 소프트웨어 객체는 현실 속의 객체를 모방하거나 추상화한 것이 아니다. 단지 의미를 쉽게 유추할 수 있도록 '은유'할 뿐이다.

> 의사소통이라는 목적에 부합한다면 용도에 맞게 얼마든지 UML을 수정하고 뒤틀어라. UML은 의사소통을 위한 표기법이지 꼭 지켜야 하는 법칙이 아니다.

아메리카노를 만들기 위한 지식은 바리스타의 상태로, 기술은 바리스타의 행동으로 간주할 수 있다.

남은 일은 메시지를 정제함으로써 각 객체의 인터페이스를 구현 가능할 정도로 상세하게 정제하는 것이다.

## B. 인터페이스 정리하기

객체가 수신한 메시지가 객체의 인터페이스를 결정한다는 사실을 기억하라. 메시지가 객체를 선택했고, 선택된 객체는 메시지를 자신의 인터페이스로 받아들인다.

각 객체를 협력이라는 문맥에서 떼어내어 수신 가능한 메시지만 추려내면 객체의 인터페이스가 된다.

소프트웨어의 구현은 동적인 객체가 아닌 정적인 타입을 이용해 이뤄진다. 따라서 객체들을 포괄하는 타입을 정의한 후 식별된 오퍼레이션을 타입의 인터페이스에 추가해야 한다.

객체의 타입을 구현하는 일반적인 방법은 클래스를 이용하는 것이다. 협력을 통해 식별된 타입의 오퍼레이션은 외부에서 접근 가능한 공용 인터페이스의 일부이다. 따라서 인터페이스에 포함된 오퍼레이션은 외부에서 접근 가능하도록 공용(public)으로 선언돼 있어야 한다.

```java
class Customer {
  public void order(String menuName) {}
}
...
```

## C. 구현하기

객체가 다른 객체에게 메시지를 전송하기 위해서는 먼저 객체에 대한 참조를 얻어야 한다. 따라서 Customer 객체는 어떤 방법으로든 자신과 협력하는 Menu 객체와 Barista 객체에 대한 참조를 알고 있어야 한다.

```java
class Customer {
  public void order(String menuName, Menu menu, Barista barista) {}
}
```

구현 도중에 객체의 인터페이스가 변경될 수 있다는 점을 눈여겨보자.

> 설계 작업은 구현을 구현을 위한 스케치를 작성하는 단계지 구현 그 자체일 수는 없다. 중요한 것은 설계가 아니라 코드다. 최대한 빨리 코드를 구현해서 설계에 이상이 없는지, 설계가 구현 가능한지를 판단해야 한다. 코드를 통한 피드백 없이는 깔끔한 설계를 얻을 수 없다.

```java
class Menu {
  private List<MenuItem> items;
  
  public Menu(List<MenuItem> items) {
    this.items = items;
  }
  
  public MenuItem choose(String name) {
    for(MenuItem each : items) {
      if (each.getName().equals(name)) {
        return each;
      }
    }
    return null;
  }
}
```

> 객체의 속성은 객체의 내부 구현에 속하기 때문에 캡슐화돼야 한다. 객체의 속성이 캡슐화된다는 이야기는 인터페이스에는 객체의 내부 속성에 대한 어떤 힌트도 제공돼서는 안 된다는 것을 의미한다. 이를 위한 가장 훌륭한 방법은 인터페이스를 정하는 단계에서는 객체가 어떤 속성을 가지는지, 또 그 속성이 어떤 자료 구조로 구현됐는지를 고려하지 않는 것이다. 객체에게 책임을 할당하고 인터페이스를 결정할 때는 가급적 객체 내부의 구현에 대한 어떤 가정도 하지 말아야 한다. 객체가 어떤 책임을 수행해야 하는지를 결정한 후에야 책임을 수행하는 데 필요한 객체의 속성을 결정하라. 이것이 객체의 구현 세부 사항을 공용 인터페이스에 노출시키지 않고 인터페이스와 구현을 깔끔하게 분리할 수 있는 기본적인 방법이다.

```java
class Coffee {
  private String name;
  privat int price;
  
  public Coffee(MenuItem menuItem) {
    this.name = menuItem.getName();
    this.price = menuItem.cost();
  }
}
```

```java
public class MenuItem {
  private String name;
  private int price;
  
  public MenuItem(String name, int price) {
    this.name = name;
    this.price = price;
  }
  
  public int cost() {
    return price;
  }
  
  public String getName() {
    return name;
  }
}
```

> 인터페이스를 통해 실제로 상호작용을 해보지 않은 채 인터페이스의 모습을 정확하게 예측하는 것은 불가능에 가깝다.
> 설계를 간단히 끝내고 최대한 빨리 구현에 돌입하라. 실제로 코드를 작성해가면서 협력의 전체적인 밑그림을 그려보라. 테스트-주도 설계로 코드를 구현하는 사람들이 하는 작업이 바로 이것이다. 그들은 테스트 코드를 작성해 가면서 협력을 설계한다.

메시지가 객체를 결정한다는 말의 의미, 책임을 따라 설계가 이뤄지는 과정, 인터페이스와 구현의 분리

# 3. 코드와 세 가지 관점

## A. 코드는 세 가지 관점을 모두 제공해야 한다

개념 관점에서 코드를 보면.

Barista라는 클래스가 커피를 제조할 것이라고 쉽게 유추할 수 있다. 

소프트웨어 클래스와 도메인 클래스 사이의 간격이 좁으면 좁을수록 기능을 변경하기 위해 뒤적거려야 하는 코드의 양도 점점 줄어든다.

명세 관점은 클래스의 인터페이스를 바라본다.

공용 인터페이스는 외부의 객체가 해당 객체에 접근할 수 있는 유일한 부분이다.

객체의 인터페이스는 수정하기 어렵다는 사실을 명심하라. 최대한 변화에 안정적인 인터페이스를 만들기 위해서는 인터페이스를 통해 구현과 관련된 세부 사항이 드러나지 않게 해야 한다. 변화에 탄력적인 인터페이스를 만들 수 있는 능력은 객체지향 설계자의 수준을 가늠하는 중요한 척도다.

구현 관점은 클래스의 내부 구현을 바라본다.

메서드의 구현과 속성의 변경은 원칙적으로 외부의 객체에게 영향을 미쳐서는 안 된다. 이것은 메서드와 속성이 철저하게 클래스 내부로 캡슐화돼야 한다는 것을 의미한다.

훌륭한 객체지향 프로그래머는 하나의 클래스 안에 세 가지 관점을 모두 포함하면서도 각 관점에 대응되는 요소를 명확하고 깔끔하게 드러낼 수 있다.

## B. 도메인 개념을 참조하는 이유

어떤 메시지가 있을 때 그 메시지를 수신할 객체를 어떻게 선택하는가? 첫 번째 전략은 도메인 개념 중에서 가장 적절한 것을 선택하는 것이다.

소프트웨어는 항상 변한다. 설계는 변경을 위해 존재한다. 소프트웨어 클래스가 도메인 개념을 따르면 변화에 쉽게 대응할 수 있다. (여러 개의 클래스로 기능을 분할하고 클래스 안에서 인터페이스와 구현을 분리하는 이유는 변경이 발생했을 때 코드를 좀 더 수월하게 수정하길 간절히 원하기 때문이다.)

## C. 인터페이스와 구현을 분리하라

명세 관점은 클래스의 안정적인 측면을 드러내야 한다. 구현 관점은 클래스의 불안정한 측면을 드러내야 한다.

명세 관점이 설계를 주도하게 하면 설계의 품질이 향상될 수 있다.
